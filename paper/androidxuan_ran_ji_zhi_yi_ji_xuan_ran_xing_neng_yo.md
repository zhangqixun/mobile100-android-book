# Android渲染机制以及渲染性能优化(1501210616 刘璐)
对Android绘图机制的理解，在Android学习中可谓至关重要,现在越来越多的应用开始重视流畅度方面的测试，了解Android应用程序是如何在屏幕上显示的则是基础中的基础，而这篇文章就是讲述Android的渲染机制以及如何对渲染进行性能优化。


### **一．渲染机制**



Android应用程序显示的过程可以概括为一句话：Android应用程序调用SurfaceFlinger服务把经过测量、布局和绘制后的Surface渲染到显示屏幕上。SurfaceFlinger是Android系统服务，负责管理Android系统的帧缓冲区，即显示屏幕。而Surface代表的是Android应用的每个窗口对应一个画布即Surface，可以理解为Android应用程序的一个窗口。

**1.UI组件**

一个Android应用程序窗口里面包含了很多UI元素，所有的视图都被排列在一个独立的视图树中，你可以通过硬编码的形式添加视图，或者在一个或者多个xml文件中指定一个视图树。如下图所示：![](liulu1.png)

作为容器的ViewGroup可以包含作为叶子节点的View，也可以包含作为更低层次的子ViewGroup，而子ViewGroup又可以包含下一层的叶子节点的View和ViewGroup。View类代表UI组件的基本创建块。一个View视图占用屏幕的一个矩形区域，并负责绘制和事件处理。View类是基本控件的基类，用于创建UI组件（如按钮button，文本域textview等）。ViewGroup是一个可以包含其他视图的视图。视图组是布局和视图容器的基类。如FrameLayout,LinearLayout,RelativeLayout等。
如果让你在一个界面上绘制一个矩形，为了准确的画出这个矩形，你必须知道两件事情：1）矩形的位置（暂定为左上角的坐标）；2）尺寸（长和宽），Android绘制图形的时候也要知道这两件事情。在绘制一个Android应用程序窗口的UI之前，我们首先要确定它里面的各个子UI元素在父UI元素里面的大小以及位置，确定各个子UI元素在父UI元素里面的大小以及位置的过程又称为测量过程和布局过程。因此，Android应用程序窗口的UI渲染过程可以分为测量、布局和绘制三个阶段。测量阶段在measure（int, int）中完成，是一个从视图树由上到下的深度遍历过程。每个视图在递归阶段中将其尺寸规则向下传递。测量阶段结束时，每个视图保存了各自的测量规则。布局阶段发生在layout(int, int)中,也是由上到下的。在这个传递过程中，每个父类都会根据测量过程中计算出来的尺寸放置其子视图。绘制过程是通过遍历视图树并呈现有效区域内的每个视图而完成处理。因为视图树被有序遍历，这就意味着，父视图会在子视图之前被绘制，然后才是依次出现的兄弟视图（视图树深度优先遍历）。

**2.SurfaceFlinger服务**

   SurfaceFlinger服务运行在Android系统的System进程中，它负责管理Android系统的帧缓冲区。Android设备的显示屏被抽象为一个帧缓冲区，而SurfaceFlinger服务就是通过向这个帧缓冲区写入内容来绘制应用程序的用户界面的。Android应用程序窗口请求SurfaceFlinger服务创建了一个绘图表面之后，就可以接着请求为该绘图表面创建图形缓冲区，而当Android应用程序窗口往这些图形缓冲区填充好UI数据之后，就可以请求SurfaceFlinger服务将它们渲染到硬件帧缓冲区中去，这样我们就可以看到应用程序窗口的UI了。Android应用程序为了能够将自己的UI绘制在系统的帧缓冲区上，它们就必须要与SurfaceFlinger服务进行通信，它们之间的关系如下图所示：

 ![](liulu2.png)
 
 如上图所示，每一个Android应用程序和SurfaceFlinger服务有一个连接，这个连接是Binder对象来完成的。图中的Client对象是Android应用程序连接到SurfaceFlinger服务的时候由SurfaceFlinger服务创建的，当连接成功之后，Android应用程序就可以获得一个对应的Client对象的Binder接口，Android应用程序就可以通知其来绘制自己的UI了。
 
要想让SurfaceBinder来绘制自己的UI,Android应用程序需要将UI数据传递给SurfaceFlinger，包括绘制的区域以及位置信息等等。一个应用程序会有多个窗口，就会有多个UI数据，Android系统提供了一种匿名共享内存机制，它以驱动程序的形式实现在内核空间中。它有两个特点，一是能够辅助内存管理系统来有效地管理不再使用的内存块，二是它通过Binder进程间通信机制来实现进程间的内存共享(详细的内容不再概述）。每一个Android应用程序与SurfaceFlinger服务之间，都会通过一块匿名共享内存来传递UI数据，如下图所示:

![](liulu3.png)

单个的匿名共享内存在传递多个窗口数据时缺乏有效的管理，所以匿名共享内存就被抽象为一个更上层的数据结构SharedClient，如下图所示：

![](liulu4.png)

在每个SharedClient中，最多有31个SharedBufferStack，每个SharedBufferStack都对应一个Surface，即一个窗口。SharedBufferStack就是共享缓冲区堆栈,由Android应用程序和SurfaceFlinger程序共享，每一个SharedBufferStack就是用来描述一系列需要按照一定规则来访问的缓冲区。每一个SharedClient对应一个Android应用程序，而一个Android应用程序可能包含有多个窗口，即Surface。从这里也可以看出，一个Android应用程序至多可以包含31个窗口。

**3.渲染**

Android系统每隔16ms发出VSYNC信号，触发对UI进行渲染，那么整个过程如果保证在16ms以内就能达到一个流畅的画面。如下图所示：

![](liulu52.png)

为什么会是16ms，16ms意味着着1000/60hz，相当于60fps，这是因为人眼与大脑之间的协作无法感知超过60fps的画面更新。12fps大概类似手动快速翻动书籍的帧率，这明显是可以感知到不够顺滑的。24fps使得人眼感知的是连续线性的运动，这其实是归功于运动模糊的 效果。24fps是电影胶圈通常使用的帧率，因为这个帧率已经足够支撑大部分电影画面需要表达的内容，同时能够最大的减少费用支出。但是低于30fps是 无法顺畅表现绚丽的画面内容的，此时就需要用到60fps来达到想要的效果。

渲染是通过GPU和CPU共同完成的，CPU（测量-->布局--->记录--->执行）---->GPU(光栅化：计算每一个像素点的值）。UI组件转换到屏幕显示的原理过程：核心步骤：rasterization光栅化，其含义就是将图转化为一个个栅格组成的图象，每一个元素对应于帧缓冲区中的一个像素。如下图所示：

![](liulu6.png)

Rasterization是非常的消耗资源，所以上个世纪90年代引入了单独的图像处理单元GPU。GPU使用一些指定的基础指令集（polygons多边形，textures 文理，images 图像)，而CPU在画东西到屏幕前，会给GPU输入这些指令，这一过程通常使用的API就是Android的OpenGL ES。这意味着如果画一个button，会在CPU中先转化为polygons多边形、texture纹理，传递给GPU进行光栅化。过程如下图所示：

![](liulu7.png)

例如显示图片的时候，需要先经过CPU的计算加载到内存中，然后传递给GPU进行渲染。文字的显示更加复杂，需要先经过CPU换算成纹理，然后再交给GPU进行渲染，回到CPU绘制单个字符的时候，再重新引用经过GPU渲染的内容。动画则是一个更加复杂的操作流程。

### **二．性能优化**


**1.Overdraw的检测与优化**

Overdraw(过度绘制)描述的是屏幕上的某个像素在同一帧的时间内被绘制了多次。在多层次的UI结构里面，如果不可见的UI也在做绘制的操作，这就会导致某些像素区域被绘制了多次。这就浪费大量的CPU以及GPU资源。当设计上追求更华丽的视觉效果的时候，我们就容易陷入采用越来越多的层叠组件来实现这种视觉效果的怪圈。这很容易导致大量的性能问题，为了获得最佳的性能，我们必须尽量减少Overdraw的情况发生。我们可以通过手机设置里面的开发者选项，打开Show GPU Overdraw的选项，可以观察UI上的Overdraw情况。

![](liulu8.png)

蓝色，淡绿，淡红，深红代表了4种不同程度的Overdraw情况，目标就是尽量减少红色Overdraw，看到更多的蓝色区域。我检查了自己的天气预报项目，得到的结果如下图所示：

![](liulu9.PNG)

可以看到过度绘制的情况还是存在，有时候是因为UI布局存在大量重叠的部分，还有的时候是因为非必须的重叠背景。例如某个Activity有一个背景，然后里面的Layout又有自己的背景，同时子View又分别有自己的背景。仅仅是通过移除非必须的背景图片，这就能够减少大量的红色Overdraw区域，增加蓝色区域的占比。这一措施能够显著提升程序性能。Overdraw的处理方案一移除不必要的background，在我的天气预报中，Overdraw 最严重的就是selectCity界面中的返回键区域。那部分的代码布局如下，我们可以看到出现了重复定义背景颜色：

![](liulu10.png)

当我把第一个和最后一个重复的背景色删除之后，再去检测一下过度绘制，得到的结果如图：

![](liulu114.PNG)

通过上图我们可以看到，过度绘制的情况有所改善，在以后的应用开发过程中，要注意过度绘制的情况。

**2.渲染性能检测*

除了上个查看过度渲染的工具之外，我们还可以打开手机里面的开发者选项，选择Profile GPU Rendering，选中On screen as bars的选项。然后手机屏幕上就会出现三个颜色组成的小柱状图,以及一条绿线，当你的应用程序在运行时,你会看到一排柱状图在屏幕上,从左到右动态地显示,每一个垂直的柱状图代表一帧的渲染,越长的垂直柱状图表示这一帧需要渲染的时间越长.随着需要渲染的帧数越来越多,他们会堆积在一起,这样你就可以观察到这段时间帧率的变化。
在上文中我们讲过系统每隔16ms发送一次信号，下图中的绿线代表16ms,要确保一秒内达到60fps,你需要确保这些帧的每一条线都在绿色的16ms标记线之下.任何时候你看到一个竖线超过了绿色的标记现,你就会看到你的动画有卡顿现象产生。

![](liulu12.png)

每一条柱状图都由三种颜色组成: 蓝-红-黄. 这些线直接和Android的渲染流水线和他实际运行帧数的时间关联。蓝色代表测量绘制的时间,或者说它代表需要多长时间去创建和更新你的DisplayList.DisplayList的本质是一个缓冲区，它里面记录了即将要执行的绘制命令序列。这些绘制命令最终会转化为OpenGL命令由GPU执行。在Android中,一个视图在可以实际的进行渲染之前,它必须被转换成GPU所熟悉的格式,简单来说就是几条绘图命令,复杂点的可能是你的自定义的View嵌入了自定义的Path.一旦完成,结果会作为一个DisplayList对象被系统送入缓存,蓝色就是记录了需要花费多长时间在屏幕上更新视图(说白了就是执行每一个View的onDraw方法,创建或者更新每一个View的Display List对象).红色代表执行的时间,这部分是Android进行2D渲染DisplayList的时间,为了绘制到屏幕上,Android需要使用OpenGlES的API接口来绘制DisplayList.这些API有效地将数据发送到GPU,最总在屏幕上显示出来。绘制下图越复杂的视图时,需要用到的OpenGl的绘制命令也会更复杂。例如视图旋转,我们需要重新清理这个区域的视图,这样可能会影响这个视图下面的视图,因为这些视图都需要进行重新的绘制操作。橙色部分表示的是处理时间,或者说是CPU告诉GPU渲染一帧的地方,这是一个阻塞调用,因为CPU会一直等待GPU发出接到命令的回复,如果柱状图很高,那就意味着你给GPU太多的工作,太多的负责视图需要OpenGL命令去绘制和处理。保持动画流畅的关键就在于让这些垂直的柱状条尽可能地保持在绿线下面,任何时候超过绿线,你就有可能丢失一帧的内容。我的应用程序检测的结果如下：

![](liulu13.PNG)

 可以看到，在主界面的渲染的时间大部分在16ms以下，可是在选择城市界面渲染的时间就不尽如人意，可能的原因就是因为这个界面的listview需要花费更多的时间来渲染。
 
**3.布局优化**

  在布局的时候我们要减少不必要的层次，Android SDK中包含hierarchy viewer这个工具，它可以方便的查看Activity的布局，各个View的属性、measure、layout、draw的时间，如果耗时较多会用红色标记，否则显示绿色。这是我的天气预报项目的层次结构：
  
![](liulu1142.PNG)
  
  我截取了其中一个，这是我主界面的视图，如下图所示：
  
  ![](liulu15.png)
  
  从上图中我们可以看到图中的三个圆圈，这三个圈圈分别代表measure 、layout、draw的速度，并且也可以看到实际的运行的速度，如果你发现某个View上的圈是红色，那么说明这个View相对其他的View，该操作运行最慢。在这个视图中，Measure和draw的速度最慢。所以通过这个图，我们可以看到在自己的代码在哪个部分耗费了更多的时间来进行改善。并且从这个工具中，我们可以看到RelativeLayout的性能要优于LinearLayout的性能，大约在Android4.0之前，新建工程的默认main.xml中顶节点是LinearLayout，而在之后已经改为RelativeLayout，因为RelativeLayout性能更优，且可以简单实现LinearLayout嵌套才能实现的布局。所以我们要用RelativeLayout代替LineLayout。
4.0以下版本可通过hierarchy viewer查看，4.0及以上Android版本可通过设置->开发者选项->显示布局边界打开页面布局显示，看看是否有不必要的节点和嵌套。可以看到我的天气预报项目的布局如下：

![](liulu16.PNG)

也能发现在主窗口中，出现了很多的嵌套，在以后的开发中，再能实现布局的情况下尽可能的避免过多的嵌套，以此来优化布局，提升性能。

关于Android渲染以及渲染性能优化的内容还有很多，我这里也只是讲述了一部分，如果在以后开发过程中遇到app有卡顿的情况，可以通过使用上述的工具首先去检测收集数据，然后按照上面提、供的方法进行优化。